diff --git a/lib/regcomp.c b/lib/regcomp.c
index cc85f35ac58..361079d82d6 100644
--- a/lib/regcomp.c
+++ b/lib/regcomp.c
@@ -322,7 +322,7 @@ re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
 		*p++ = dfa->nodes[node].opr.c;
 	      memset (&state, '\0', sizeof (state));
 	      if (__mbrtowc (&wc, (const char *) buf, p - buf,
-			     &state) == p - buf
+			     &state) == (size_t)(p - buf)
 		  && (__wcrtomb ((char *) buf, __towlower (wc), &state)
 		      != (size_t) -1))
 		re_set_fastmap (fastmap, false, buf[0]);
@@ -3778,7 +3778,7 @@ fetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)
       num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)
 	     ? -2
 	     : num == -1
-	     ? c - '0'
+	     ? (Idx)(c - '0')
 	     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));
     }
   return num;
diff --git a/lib/regex_internal.c b/lib/regex_internal.c
index 9004ce809eb..193a1e3d332 100644
--- a/lib/regex_internal.c
+++ b/lib/regex_internal.c
@@ -233,7 +233,7 @@ build_wcs_buffer (re_string_t *pstr)
       /* Apply the translation if we need.  */
       if (__glibc_unlikely (pstr->trans != NULL))
 	{
-	  int i, ch;
+	  unsigned int i, ch;
 
 	  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)
 	    {
@@ -376,7 +376,7 @@ build_wcs_upper_buffer (re_string_t *pstr)
 	prev_st = pstr->cur_state;
 	if (__glibc_unlikely (pstr->trans != NULL))
 	  {
-	    int i, ch;
+	    unsigned int i, ch;
 
 	    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)
 	      {
@@ -754,7 +754,7 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 			  memset (&cur_state, 0, sizeof (cur_state));
 			  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,
 					      &cur_state);
-			  if (raw + offset - p <= mbclen
+			  if ((size_t)(raw + offset - p) <= mbclen
 			      && mbclen < (size_t) -2)
 			    {
 			      memset (&pstr->cur_state, '\0',
diff --git a/lib/regex_internal.h b/lib/regex_internal.h
index 5462419b787..e0f8292395d 100644
--- a/lib/regex_internal.h
+++ b/lib/regex_internal.h
@@ -425,7 +425,7 @@ struct re_string_t
   unsigned char offsets_needed;
   unsigned char newline_anchor;
   unsigned char word_ops_used;
-  int mb_cur_max;
+  unsigned int mb_cur_max;
 };
 typedef struct re_string_t re_string_t;
 
@@ -702,7 +702,7 @@ struct re_dfa_t
   unsigned int is_utf8 : 1;
   unsigned int map_notascii : 1;
   unsigned int word_ops_used : 1;
-  int mb_cur_max;
+  unsigned int mb_cur_max;
   bitset_t word_char;
   reg_syntax_t syntax;
   Idx *subexp_map;
diff --git a/lib/regexec.c b/lib/regexec.c
index 0a7a27b772e..b57d4f9141d 100644
--- a/lib/regexec.c
+++ b/lib/regexec.c
@@ -443,7 +443,7 @@ re_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,
     {
       if (ret_len)
 	{
-	  assert (pmatch[0].rm_so == start);
+	  assert (pmatch[0].rm_so == (long)start);
 	  rval = pmatch[0].rm_eo - start;
 	}
       else
@@ -877,11 +877,11 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
 	    if (__glibc_unlikely (mctx.input.offsets_needed != 0))
 	      {
 		pmatch[reg_idx].rm_so =
-		  (pmatch[reg_idx].rm_so == mctx.input.valid_len
+		  (pmatch[reg_idx].rm_so == (long)mctx.input.valid_len
 		   ? mctx.input.valid_raw_len
 		   : mctx.input.offsets[pmatch[reg_idx].rm_so]);
 		pmatch[reg_idx].rm_eo =
-		  (pmatch[reg_idx].rm_eo == mctx.input.valid_len
+		  (pmatch[reg_idx].rm_eo == (long)mctx.input.valid_len
 		   ? mctx.input.valid_raw_len
 		   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);
 	      }
@@ -1418,11 +1418,11 @@ set_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,
     }
   memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);
 
-  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)
+  for (idx = pmatch[0].rm_so; idx <= (long)pmatch[0].rm_eo ;)
     {
       update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);
 
-      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)
+      if (idx == (long)pmatch[0].rm_eo && cur_node == mctx->last_node)
 	{
 	  Idx reg_idx;
 	  if (fs)
@@ -1519,7 +1519,7 @@ update_regs (const re_dfa_t *dfa, regmatch_t *pmatch,
       if (reg_num < nmatch)
 	{
 	  /* We are at the last node of this sub expression.  */
-	  if (pmatch[reg_num].rm_so < cur_idx)
+	  if (pmatch[reg_num].rm_so < (long)cur_idx)
 	    {
 	      pmatch[reg_num].rm_eo = cur_idx;
 	      /* This is a non-empty match or we are not inside an optional
@@ -2938,7 +2938,7 @@ check_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,
       mctx->state_log[str_idx] = cur_state;
     }
 
-  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)
+  for (null_cnt = 0; str_idx < last_str && null_cnt <= (long)mctx->max_mb_elem_len;)
     {
       re_node_set_empty (&next_nodes);
       if (mctx->state_log[str_idx + 1])
@@ -3718,7 +3718,7 @@ check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
 			 const re_string_t *input, Idx str_idx)
 {
   const re_token_t *node = dfa->nodes + node_idx;
-  int char_len, elem_len;
+  unsigned int char_len, elem_len;
   Idx i;
 
   if (__glibc_unlikely (node->type == OP_UTF8_PERIOD))
@@ -4066,7 +4066,7 @@ extend_buffers (re_match_context_t *mctx, int min_len)
   /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */
   ret = re_string_realloc_buffers (pstr,
 				   MAX (min_len,
-					MIN (pstr->len, pstr->bufs_len * 2)));
+					MIN ((long)pstr->len, pstr->bufs_len * 2)));
   if (__glibc_unlikely (ret != REG_NOERROR))
     return ret;
 
@@ -4236,7 +4236,7 @@ match_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,
     = (from == to ? -1 : 0);
 
   mctx->bkref_ents[mctx->nbkref_ents++].more = 0;
-  if (mctx->max_mb_elem_len < to - from)
+  if (mctx->max_mb_elem_len < (long)(to - from))
     mctx->max_mb_elem_len = to - from;
   return REG_NOERROR;
 }
